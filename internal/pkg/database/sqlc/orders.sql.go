// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countOrders = `-- name: CountOrders :one
SELECT COUNT(*) AS total_count FROM orders
`

func (q *Queries) CountOrders(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOrders)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countOrdersByUser = `-- name: CountOrdersByUser :one
SELECT COUNT(*) AS total_count FROM orders
WHERE user_id = $1
`

func (q *Queries) CountOrdersByUser(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersByUser, userID)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    user_id,
    order_number,
    subtotal_cents,
    discount_cents,
    tax_cents,
    shipping_cents,
    total_cents,
    final_cents,
    -- currency,
    shipping_info,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
 RETURNING id, user_id, order_number, subtotal_cents, discount_cents, tax_cents, shipping_cents, total_cents, final_cents, currency, status, shipping_info, notes, created_at, updated_at
`

type CreateOrderParams struct {
	UserID        pgtype.UUID `json:"user_id"`
	OrderNumber   string      `json:"order_number"`
	SubtotalCents int64       `json:"subtotal_cents"`
	DiscountCents pgtype.Int8 `json:"discount_cents"`
	TaxCents      pgtype.Int8 `json:"tax_cents"`
	ShippingCents pgtype.Int8 `json:"shipping_cents"`
	TotalCents    int64       `json:"total_cents"`
	FinalCents    int64       `json:"final_cents"`
	ShippingInfo  []byte      `json:"shipping_info"`
	Notes         pgtype.Text `json:"notes"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.UserID,
		arg.OrderNumber,
		arg.SubtotalCents,
		arg.DiscountCents,
		arg.TaxCents,
		arg.ShippingCents,
		arg.TotalCents,
		arg.FinalCents,
		arg.ShippingInfo,
		arg.Notes,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrderNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.TotalCents,
		&i.FinalCents,
		&i.Currency,
		&i.Status,
		&i.ShippingInfo,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM orders
WHERE id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrder, id)
	return err
}

const getOrderWithItemsByID = `-- name: GetOrderWithItemsByID :one



SELECT 
    o.id, o.user_id, o.order_number, o.subtotal_cents, o.discount_cents, o.tax_cents, o.shipping_cents, o.total_cents, o.final_cents, o.currency, o.status, o.shipping_info, o.notes, o.created_at, o.updated_at,
    COALESCE(
        json_agg(to_jsonb(oi)) FILTER (WHERE oi.id IS NOT NULL), '[]'
    ) AS items
FROM orders o
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE o.id = $1
GROUP BY o.id
`

type GetOrderWithItemsByIDRow struct {
	ID            pgtype.UUID        `json:"id"`
	UserID        pgtype.UUID        `json:"user_id"`
	OrderNumber   string             `json:"order_number"`
	SubtotalCents int64              `json:"subtotal_cents"`
	DiscountCents pgtype.Int8        `json:"discount_cents"`
	TaxCents      pgtype.Int8        `json:"tax_cents"`
	ShippingCents pgtype.Int8        `json:"shipping_cents"`
	TotalCents    int64              `json:"total_cents"`
	FinalCents    int64              `json:"final_cents"`
	Currency      string             `json:"currency"`
	Status        string             `json:"status"`
	ShippingInfo  []byte             `json:"shipping_info"`
	Notes         pgtype.Text        `json:"notes"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Items         interface{}        `json:"items"`
}

// -- name: GetOrderByID :one
// SELECT * FROM orders
// WHERE id = $1 LIMIT 1;
// -- name: GetOrdersByUserID :many
// SELECT * FROM orders
// WHERE user_id = $1
// ORDER BY created_at DESC;
// -- name: GetOrders :many
// SELECT * FROM orders
// ORDER BY created_at DESC
// LIMIT $1 OFFSET $2;
func (q *Queries) GetOrderWithItemsByID(ctx context.Context, id pgtype.UUID) (GetOrderWithItemsByIDRow, error) {
	row := q.db.QueryRow(ctx, getOrderWithItemsByID, id)
	var i GetOrderWithItemsByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrderNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.TotalCents,
		&i.FinalCents,
		&i.Currency,
		&i.Status,
		&i.ShippingInfo,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Items,
	)
	return i, err
}

const getOrdersWithItems = `-- name: GetOrdersWithItems :many
SELECT 
    o.id, o.user_id, o.order_number, o.subtotal_cents, o.discount_cents, o.tax_cents, o.shipping_cents, o.total_cents, o.final_cents, o.currency, o.status, o.shipping_info, o.notes, o.created_at, o.updated_at,
    COALESCE(
        json_agg(to_jsonb(oi)) FILTER (WHERE oi.id IS NOT NULL), '[]'
    ) AS items
FROM orders o
LEFT JOIN order_items oi ON o.id = oi.order_id
GROUP BY o.id
ORDER BY o.created_at DESC
LIMIT $1 OFFSET $2
`

type GetOrdersWithItemsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetOrdersWithItemsRow struct {
	ID            pgtype.UUID        `json:"id"`
	UserID        pgtype.UUID        `json:"user_id"`
	OrderNumber   string             `json:"order_number"`
	SubtotalCents int64              `json:"subtotal_cents"`
	DiscountCents pgtype.Int8        `json:"discount_cents"`
	TaxCents      pgtype.Int8        `json:"tax_cents"`
	ShippingCents pgtype.Int8        `json:"shipping_cents"`
	TotalCents    int64              `json:"total_cents"`
	FinalCents    int64              `json:"final_cents"`
	Currency      string             `json:"currency"`
	Status        string             `json:"status"`
	ShippingInfo  []byte             `json:"shipping_info"`
	Notes         pgtype.Text        `json:"notes"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Items         interface{}        `json:"items"`
}

func (q *Queries) GetOrdersWithItems(ctx context.Context, arg GetOrdersWithItemsParams) ([]GetOrdersWithItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrdersWithItems, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrdersWithItemsRow{}
	for rows.Next() {
		var i GetOrdersWithItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OrderNumber,
			&i.SubtotalCents,
			&i.DiscountCents,
			&i.TaxCents,
			&i.ShippingCents,
			&i.TotalCents,
			&i.FinalCents,
			&i.Currency,
			&i.Status,
			&i.ShippingInfo,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Items,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersWithItemsByUserID = `-- name: GetOrdersWithItemsByUserID :many
SELECT 
    o.id, o.user_id, o.order_number, o.subtotal_cents, o.discount_cents, o.tax_cents, o.shipping_cents, o.total_cents, o.final_cents, o.currency, o.status, o.shipping_info, o.notes, o.created_at, o.updated_at,
    COALESCE(
        json_agg(to_jsonb(oi)) FILTER (WHERE oi.id IS NOT NULL), '[]'
    ) AS items
FROM orders o
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE o.user_id = $1
GROUP BY o.id
ORDER BY o.created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrdersWithItemsByUserIDParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetOrdersWithItemsByUserIDRow struct {
	ID            pgtype.UUID        `json:"id"`
	UserID        pgtype.UUID        `json:"user_id"`
	OrderNumber   string             `json:"order_number"`
	SubtotalCents int64              `json:"subtotal_cents"`
	DiscountCents pgtype.Int8        `json:"discount_cents"`
	TaxCents      pgtype.Int8        `json:"tax_cents"`
	ShippingCents pgtype.Int8        `json:"shipping_cents"`
	TotalCents    int64              `json:"total_cents"`
	FinalCents    int64              `json:"final_cents"`
	Currency      string             `json:"currency"`
	Status        string             `json:"status"`
	ShippingInfo  []byte             `json:"shipping_info"`
	Notes         pgtype.Text        `json:"notes"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Items         interface{}        `json:"items"`
}

func (q *Queries) GetOrdersWithItemsByUserID(ctx context.Context, arg GetOrdersWithItemsByUserIDParams) ([]GetOrdersWithItemsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getOrdersWithItemsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrdersWithItemsByUserIDRow{}
	for rows.Next() {
		var i GetOrdersWithItemsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OrderNumber,
			&i.SubtotalCents,
			&i.DiscountCents,
			&i.TaxCents,
			&i.ShippingCents,
			&i.TotalCents,
			&i.FinalCents,
			&i.Currency,
			&i.Status,
			&i.ShippingInfo,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Items,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders
SET 
    status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, order_number, subtotal_cents, discount_cents, tax_cents, shipping_cents, total_cents, final_cents, currency, status, shipping_info, notes, created_at, updated_at
`

type UpdateOrderStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderStatus, arg.ID, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrderNumber,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.TotalCents,
		&i.FinalCents,
		&i.Currency,
		&i.Status,
		&i.ShippingInfo,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
